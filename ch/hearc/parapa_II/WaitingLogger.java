package ch.hearc.parapa_II;

import java.io.Console;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.FutureTask;
import java.util.concurrent.locks.ReentrantLock;
import java.util.stream.Collectors;

import ch.hearc.parapa_II.Log.Type;
import ch.hearc.parapa_II.Log;

public class WaitingLogger {
	// Singleton lock
	private final static ReentrantLock lockSingleton = new ReentrantLock();
	private static WaitingLogger instance;

	private ConcurrentLinkedQueue<Person> waitingList;
	private ConcurrentLinkedQueue<Person> processingList;
	private ConcurrentLinkedQueue<Person> finishedList;
	private ConcurrentLinkedQueue<Log> logs;

	// Variables
	private ArrayList<Person> persons;

	// Singletons
	private Database db;

	private FutureTask<String> consoleFuture;

	/**
	 * Constructor
	 */
	private WaitingLogger() {
		db = Database.getInstance();

		waitingList = new ConcurrentLinkedQueue<Person>();
		processingList = new ConcurrentLinkedQueue<Person>();
		finishedList = new ConcurrentLinkedQueue<Person>();
		logs = new ConcurrentLinkedQueue<Log>();

		persons = new ArrayList<Person>();
	}

	/**
	 * Singleton instance
	 * 
	 * @return the instance of the waiting logger
	 */
	public static WaitingLogger getInstance() {
		lockSingleton.lock();
		if (instance == null) {
			instance = new WaitingLogger();
		}
		lockSingleton.unlock();

		return instance;
	}

	/**
	 * Assign the future task to be able to cancel it when all threads are done
	 * 
	 * @param consoleFuture Future task running the main thread
	 * @param persons       List of persons generated by the main thread
	 */
	public void assignConsoleFuture(FutureTask<String> consoleFuture, ArrayList<Person> persons) {
		this.consoleFuture = consoleFuture;
		this.persons = persons;
	}

	/**
	 * Add a thread to the waiting queue
	 * 
	 * @param p     Person waiting to access a document
	 * @param timer Time of the operation
	 */
	public void addWaiting(Person p, long timer) {
		logs.add(new Log(Log.Type.WAITING, p, timer));
	}

	/**
	 * Remove a thread from the waiting queue and add it to the processing queue
	 * 
	 * @param p     Person accessing the document
	 * @param timer Time of the operation
	 */
	public void removeWaiting(Person p, long timer) {
		logs.add(new Log(Log.Type.REMOVE, p, timer));
	}

	/**
	 * Remove a thread from the processing queue
	 * 
	 * @param p     Person finishing to access the document
	 * @param timer Time of the operation
	 */
	public void finished(Person p, long timer) {
		logs.add(new Log(Log.Type.FINISHED, p, timer));
	}

	/**
	 * Called by the user on typing 'NEXT', display the next operation logged
	 */
	public void popNextLog() {
		if (logs.size() == 0) {
			System.out.println("No logs available yet, wait a moment...");
			return;
		}

		Log nextLog = logs.poll();

		Person p = nextLog.getPerson();

		// Treat log type
		switch (nextLog.getType()) {
			case WAITING:
				waitingList.add(p);

				// add to log : multiple spaces (number of time of log) + "W"
				String log = p.getLog();
				log += " ".repeat((int) nextLog.getTime() / 100) + "W";
				p.setLog(log);

				break;
			case REMOVE:
				waitingList.remove(p);
				processingList.add(p);

				char c = 'R';
				log = p.getLog();
				int logLength = p.getLog().length();

				if ((int) p.getStartingTime() / 10 == (int) nextLog.getTime() / 10) {
					c = 'T';
					log = log.replace('W', c);
				} else {
					int nbSpaces = ((int) nextLog.getTime() / 100) - logLength;
					log += " ".repeat(nbSpaces) + c;
				}

				p.setLog(log);

				break;
			case FINISHED:
				processingList.remove(p);
				finishedList.add(p);

				log = p.getLog();
				logLength = p.getLog().length();

				int nbLines = ((int) nextLog.getTime() / 100) - logLength;

				log += "-".repeat(nbLines) + "F";
				p.setLog(log);

				break;
			default:
				break;
		}

		System.out.println("\n-- Threads list -----------------------------");

		for (Person person : persons) {
			System.out.println(
					person.getName() + " (" + person.getRole().toString() + ") start : "
							+ person.getStartingTime()
							+ " / duration : " + person.getDurationTime() + "("
							+ person.getDocument().getName()
							+ ")");
		}

		System.out.println("\n-- Queues state -----------------------------\n");

		db.getNames().forEach(name -> {
			// find all the persons that are waiting for this document
			List<Person> waitingForThisDocument = waitingList.stream()
					.filter(person -> person.getDocument().getName().equals(name))
					.collect(Collectors.toList());

			// find all the persons that are processing this document
			List<Person> processingForThisDocument = processingList.stream()
					.filter(person -> person.getDocument().getName().equals(name))
					.collect(Collectors.toList());

			// concatenate the processingForThisDocument persons names
			String processingForThisDocumentNames = processingForThisDocument.stream()
					.map(person -> person.getName() + " (" + person.getRole().toString() + ") ")
					.collect(Collectors.joining());

			// concatenate the waitingForThisDocument persons names
			String waitingForThisDocumentNames = waitingForThisDocument.stream()
					.map(person -> person.getName() + " (" + person.getRole().toString() + ") ")
					.collect(Collectors.joining());

			// display the document name and the persons that are processing and waiting for
			// it
			System.out.println(name + " (WAITING) : " + waitingForThisDocumentNames);
			System.out.println(name + " (PROCESSING) : " + processingForThisDocumentNames + "\n");
		});

		System.out.println("\n-- Diagram ----------------------------------\n");

		System.out.println("W : Waiting / R : Removed from waiting / T : W + R / F : Finished\n");

		// System.out.println("Scale : " + nextLog.getTime() + "ms\n");

		// Print the scale, with 10 spaces between each number
		System.out.print(" ".repeat(20));
		for (int i = 0; i <= nextLog.getTime() / 1000; i++) {
			System.out.print(i + " ".repeat(10 - String.valueOf(i).length()));
		}
		System.out.println();

		for (Person person : persons) {
			// find the person in the processing list
			Optional<Person> processingPerson = processingList.stream()
					.filter(p_ -> p_.getName().equals(person.getName())).findFirst();

			// display the waiting + removed from waiting part of the diagram
			if (processingPerson.isPresent()) {
				String log = person.getLog();
				int nbLines = ((int) nextLog.getTime() / 100) - log.length() + 1;

				if (nextLog.getTime() / 1000 >= 10)
					nbLines++;

				if (nbLines > 0)
					log += "-".repeat(nbLines);

				person.setLog(log);
			}

			System.out.println(person.getName() + " (" + person.getRole().toString() +
					") : "
					+ person.getLog());
		}

		if (logs.isEmpty() && finishedList.size() == persons.size()) {
			System.out.println("All threads are done, exiting...");
			consoleFuture.cancel(true);
			return;
		}

	}
}
